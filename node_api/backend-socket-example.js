// Backend Socket Handler Example (Add this to your backend server)\n// This file shows the socket events you need to implement on your backend\n\n/*\n// In your backend server file (e.g., server.js or app.js)\nconst io = require('socket.io')(server, {\n  cors: {\n    origin: \"http://localhost:3000\",\n    methods: [\"GET\", \"POST\"]\n  }\n});\n\n// Store active users and their rooms\nconst activeUsers = new Map();\nconst requestRooms = new Map();\n\nio.on('connection', (socket) => {\n  console.log('User connected:', socket.id);\n\n  // Handle user joining a request room\n  socket.on('joinRequest', ({ requestId, userId, userName }) => {\n    socket.join(requestId);\n    \n    // Store user info\n    activeUsers.set(socket.id, { userId, userName, requestId });\n    \n    // Update room users\n    if (!requestRooms.has(requestId)) {\n      requestRooms.set(requestId, new Set());\n    }\n    requestRooms.get(requestId).add({ userId, userName, socketId: socket.id });\n    \n    // Notify room about online users\n    const roomUsers = Array.from(requestRooms.get(requestId));\n    io.to(requestId).emit('onlineUsers', roomUsers);\n    \n    console.log(`User ${userName} joined request ${requestId}`);\n  });\n\n  // Handle sending messages\n  socket.on('sendMessage', (data) => {\n    const { requestId, message, userId, userName, timestamp } = data;\n    \n    // Save message to database here\n    // const savedMessage = await Message.create({ requestId, userId, message, timestamp });\n    \n    // Broadcast message to all users in the room except sender\n    socket.to(requestId).emit('receiveMessage', {\n      message,\n      userId,\n      userName,\n      timestamp,\n      self: false\n    });\n    \n    // Send notification to other users\n    socket.to(requestId).emit('newMessageNotification', {\n      userId,\n      userName,\n      message: message.substring(0, 50) + (message.length > 50 ? '...' : '')\n    });\n    \n    console.log(`Message sent in request ${requestId} by ${userName}`);\n  });\n\n  // Handle typing indicators\n  socket.on('typing', ({ requestId, userId, isTyping }) => {\n    socket.to(requestId).emit('userTyping', { userId, isTyping });\n  });\n\n  // Handle new request creation\n  socket.on('newRequest', (requestData) => {\n    // Broadcast to all users in the area\n    socket.broadcast.emit('newRequestNotification', {\n      requestId: requestData._id,\n      userName: requestData.user.name,\n      category: requestData.category,\n      description: requestData.description\n    });\n  });\n\n  // Handle request acceptance\n  socket.on('requestAccepted', ({ requestId, helperId, helperName, requesterId }) => {\n    // Notify the requester\n    const requesterSocket = Array.from(activeUsers.entries())\n      .find(([socketId, user]) => user.userId === requesterId);\n    \n    if (requesterSocket) {\n      io.to(requesterSocket[0]).emit('requestAcceptedNotification', {\n        requestId,\n        helperName,\n        requesterId\n      });\n    }\n  });\n\n  // Handle disconnection\n  socket.on('disconnect', () => {\n    const user = activeUsers.get(socket.id);\n    \n    if (user) {\n      const { requestId, userId } = user;\n      \n      // Remove user from room\n      if (requestRooms.has(requestId)) {\n        const roomUsers = requestRooms.get(requestId);\n        roomUsers.forEach(roomUser => {\n          if (roomUser.socketId === socket.id) {\n            roomUsers.delete(roomUser);\n          }\n        });\n        \n        // Update online users for the room\n        const updatedRoomUsers = Array.from(roomUsers);\n        io.to(requestId).emit('onlineUsers', updatedRoomUsers);\n        \n        // Clean up empty rooms\n        if (roomUsers.size === 0) {\n          requestRooms.delete(requestId);\n        }\n      }\n      \n      activeUsers.delete(socket.id);\n    }\n    \n    console.log('User disconnected:', socket.id);\n  });\n});\n\n// Additional API endpoints you might need:\n\n// GET /api/requests/:requestId/messages - Get chat history\napp.get('/api/requests/:requestId/messages', async (req, res) => {\n  try {\n    const { requestId } = req.params;\n    // const messages = await Message.find({ requestId }).populate('userId', 'name').sort({ createdAt: 1 });\n    // res.json(messages);\n    res.json([]); // Return empty array for now\n  } catch (error) {\n    res.status(500).json({ error: error.message });\n  }\n});\n\n// POST /api/requests/:requestId/messages - Save message (if needed)\napp.post('/api/requests/:requestId/messages', async (req, res) => {\n  try {\n    const { requestId } = req.params;\n    const { message, userId } = req.body;\n    \n    // const savedMessage = await Message.create({ requestId, userId, message });\n    // res.json(savedMessage);\n    res.json({ success: true });\n  } catch (error) {\n    res.status(500).json({ error: error.message });\n  }\n});\n*/\n\n// Message Schema Example (if using MongoDB/Mongoose)\n/*\nconst messageSchema = new mongoose.Schema({\n  requestId: { type: mongoose.Schema.Types.ObjectId, ref: 'Request', required: true },\n  userId: { type: mongoose.Schema.Types.ObjectId, ref: 'User', required: true },\n  message: { type: String, required: true },\n  timestamp: { type: Date, default: Date.now },\n  messageType: { type: String, enum: ['text', 'image', 'location'], default: 'text' },\n  isRead: { type: Boolean, default: false }\n});\n\nconst Message = mongoose.model('Message', messageSchema);\n*/\n\nexport default null; // This is just a reference file